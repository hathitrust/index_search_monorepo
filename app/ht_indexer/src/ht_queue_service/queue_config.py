import copy
import yaml
import dataclasses
import os
from pathlib import Path
from typing import Any


@dataclasses.dataclass
class QueueParams:
    host: str
    port: int
    user: str
    password: str
    # Parameters defining by each application
    queue_name: str
    batch_size: int
    requeue_message: bool
    exchange_type: str
    durable: bool
    auto_delete: bool
    exclusive: bool
    heartbeat: int
    connection_timeout: int
    retry_interval: int
    shutdown_on_empty_queue: bool
    # Parameters generated by the QueueConfig using the queue_name
    main_exchange_name: str # Main exchange name
    dlx_exchange: str # Dead-letter exchange name
    dlx_routing_key: str # Dead-letter routing key
    dlx_queue_name: str # Dead-letter queue name
    arguments: dict[str, Any] # Can be provided by the user or generated by the QueueConfig

def _load_config(config_path: Path) -> dict[str, Any]:
    with open(config_path) as file:
        return yaml.safe_load(file)


class QueueConfig:

    ENV_MAPPING = {
        "host": "QUEUE_HOST",
        "port": "QUEUE_PORT",
        "user": "QUEUE_USER",
        "password": "QUEUE_PASS",
        "queue_name": "QUEUE_NAME"
    }

    def __init__(self, global_path: Path, app_path: Path, config_key: str="queue") -> None:
        """
        Initialize the QueueConfig with default values or load from a YAML file.

        :param global_path: Path to the global YAML configuration file.
        :param app_path: Path to the application-specific YAML configuration file.
        :param config_key: Key to identify the specific queue configuration in the YAML files.
        """

        default_global_config = _load_config(global_path)["queue"]

        # Load the global configuration
        global_cfg = self._merge_env_vars(default_global_config)

        default_app_config = _load_config(app_path)[config_key]

        # Merge the configurations, with app_config taking precedence
        app_cfg = {**global_cfg, **default_app_config}

        # Load the application-specific configuration
        self.merged_config = self._merge_env_vars(app_cfg)

        self.queue_params = QueueParams(**self._create_queue_params())


    def _merge_env_vars(self, config: dict[str, Any]) -> dict[str, Any]:

        """
        Merge environment variables with the configuration file values.
        Environment variables take precedence over config file values.
        """

        queue_cfg = copy.deepcopy(config)

        # Override with environment variables if they exist
        # Environment variables take precedence over config file values
        for key, env_var in self.ENV_MAPPING.items():
            env_value = os.getenv(env_var)
            if env_value is not None:
                if key == "port":  # cast port to int if overridden
                    env_value = int(env_value)
                queue_cfg[key] = env_value

        return queue_cfg

    def _create_queue_params(self) -> dict[str, Any]:
        """
        Create and return a QueueParams object with the current configuration.
        """

        queue_cfg = copy.deepcopy(self.merged_config)

        queue_cfg["main_exchange_name"] = f"{queue_cfg["queue_name"]}_exchange"
        # Apply DLX arguments
        queue_cfg["dlx_exchange"] = f"{queue_cfg["queue_name"]}_dlx_exchange"
        queue_cfg["dlx_routing_key"] = f"dlx_key_{queue_cfg["queue_name"]}"
        queue_cfg["dlx_queue_name"] = f"{queue_cfg["queue_name"]}_dlq"

        # Ensure 'arguments' exists
        if self.merged_config.get("arguments", {}):
            queue_cfg["arguments"] = self.merged_config["arguments"]
        else:
            queue_cfg["arguments"] = {
                "x-dead-letter-exchange": queue_cfg["dlx_exchange"],
                "x-dead-letter-routing-key": queue_cfg["dlx_routing_key"]
            }

        return queue_cfg

    def get_params(self) -> QueueParams:
        return self.queue_params